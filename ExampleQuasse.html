<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title>Paralellizing QuaSSE - Options and Approaches</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1>Paralellizing QuaSSE - Options and Approaches</h1>

<p>From the tutorial, begin with an unparallelized version. </p>

<p>Well start with a simulated tree. The tree simulation differs slightly from the other methods, because
there is no longer a canonical argument list (speciation and extinction rates are arbitrary functions of the
character state). Here is a set of functions; speciation rate is a sigmoidal function which ranges from 0.1
to 0.2 with an inflection point at x = 0, extinction is constant at rate 0.03, and the model of character
evolution is Brownian motion with diffusion parameter 0.025.</p>

<pre><code class="r"># set knitr options
opts_chunk$set(message = FALSE, warning = FALSE)
</code></pre>

<pre><code class="r">require(diversitree)
lambda &lt;- function(x) sigmoid.x(x, 0.1, 0.2, 0, 2.5)
mu &lt;- function(x) constant.x(x, 0.03)
char &lt;- make.brownian.with.drift(0, 0.025)
</code></pre>

<p>You can also embed plots, for example:</p>

<pre><code class="r">set.seed(1)
phy &lt;- tree.quasse(c(lambda, mu, char), max.taxa = 7, x0 = 0, single.lineage = FALSE)
plot(phy)
</code></pre>

<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfgAAAGwCAMAAABy/YdMAAAAbFBMVEX9/v0AAAAAADkAAGUAOY8AZmUAZrU5AAA5ADk5AGU5OY85j485j7U5j9plAABlADllAGVlOTllOY9ltf2POQCPOTmPOWWPZgCPZo+P2/21ZgC1/v3ajzna/rXa/v39tWX924/9/rX9/tr9/v2fTSn4AAAAJHRSTlP//////////////////////////////////////////////wBYLA0NAAAACXBIWXMAAAsSAAALEgHS3X78AAAII0lEQVR4nO3dC3PbRBRA4boNfYHTQs0jjqkd+///RyyFmWgzpiPuStpdnfPNlKEzVLe7B8cFyvWbi5DelP4JqAzDQxkeyvBQhocyPJThoQwPZXgow0MZHsrwUIaHMjyU4aEMD2V4KMNDGR7K8FCGhzI8lOGhDA9leCjDQxkeyvBQhocyPJThoQwPZXgow0MZHsrwUIaHMjyU4aEMD2V4KMNDGR7K8FCGhzI8lOGhDA9leCjDQxkeyvBQhocyPJThoQwPZXgow0MZHsrwUIaHMjyU4aEMD2V4KMM37HD3PfxjDd+u42Yb/8GGb8fT/Wbz7XL8ZbfpX+mnz39+iz/M8O3Yby+nT4/7tw/dn127//3lIf6wVYbfrFP/pf38+7X28f3l6evj6XP8LX6l4Uv/BOZyfbU//fa9C9/1v+aPM3wzDtfOh23/Mt9vj/3XgIzyhm/G8d1jV/z6x8P1279f9MMM34599xLf/3y/6bt37/IZDzN8W867jH+EGzJ8W/Je5gOGhzI8lOGhDA9leCjDQxkeyvBQhocyPJThoQwPZXgow0MZHsrwUIaHMjyU4aEMD2V4KMNDGR7K8FCGhzI8lOGhDA9leCjDQxkeyvBQhocyPJThoQzfrP3GJcavIMLv32dtQjJ8O5Lt1adPeeuvDN+OZHv14af7TcbnFBh+jvELbK8+7949nne+x6dKh5/tyYPt1d2Gy5z11YZvZnyyvbp/4R98xafWGT7dXn39Rf3po59QkVpn+HR79Xm3eeva8ldWGr7j9uofWXF4t1f/yIrDT8bwqxs/juFXN34cw69u/DiLh5/r32cmlj7UqyOWHT/O8uFXMqPe8eMYfnXjxzH86saPY/jVjR/H8KsbP47hVzd+HMOvbvw4hl/d+HEMv7rx4xh+dePHMfzqxo9j+NiEiv9TwTiGn36C4W8xfB0MP/0Ew99i+DoYfvoJhr/F8HUw/PQTDH+L4etg+OknGP4Ww9fB8NNPMPwthq+D4aefYPhbDF8Hw08/wfC3GL4Ohp9+guFvMXwdDD/9hGXCHzabnL1Xhp9+wiLh+w2HGQw//YS5xifbq59+/dDvu4sy/PQT5hqfbK8+Pm+3DDP89BPmWvAy3F7dD+r32gYZvtIJN71sr+6/a/jFZ5QIn2yv7j+g4uCX+qVnlAifbK/udtoec7YYG77SCTck26uvv8Rva3u14bO0u73a8Fna3V5t+DoYvtIJczN8pRPmZvhKJ8zN8JVOmJvhK50wN8NXOmFuhq90wtwMX+mEuRm+0glzM3ylE+Zm+EonzM3wlU6Ym+ErnTA3w1c6YW6Gr3TC3NYZfn4LnGJeqww/v/ZPYfiQ9k9h+JD2T2H4kPZPYfiQ9k9h+JD2T2H4kPZPYfiQ9k9h+JD2T2H4kPZPYfiQ9k9h+JD2T2H4kPZPYfiQ9k9h+JD2T2H4kPZPYfiQ9k9h+JD2T2H4kApOcfrQbbYNM3xI+VM8fXnov0UZPqTIKdLt1V8fL/16yyDDh5RZcDjcXt19UMFdfJWt4WPyTxH4Ld3J9urD3ffzbhufb/iQCcJHftDL9urh9vIQw4eUCJ9sr+43XB58xS+tRPhke3X/hv/R7dVLK/Kl3u3V5RV6j69zezXlfzfsFAtf4/bqcUcx/FRPyGP4EMMPGH7ZJ+QxfIjhBwy/7BPyGD7E8AOGX/YJeQwfYvgBwy/7hDyGDzH8gOGXfUIew4cYfsDwyz4hj+FDDD9g+GWfkMfwIYYfQIXPV/gEhi+k9D0YvpDS92D4Qkrfg+ELKX0Phi+k9D0YvpDS92D4Qkrfg+ELKX0Phi+k9D0YvpDS92D4Qkrfg+ELKX0Phi+k9D0YvpDS92D4Qkrfg+ELKX0Phi+k9D0YvpDS92D4Qkrfg+ELyb2HY/8b9+IrsAxfyBT3cMjYYmz4QgL3kKwtvzpWsr3a8P9H4B7SteVZH1Ng+GICvxM/WVv+vNQ4zvAteVlbnvuCN3w7krXlecvqL4ZvSLq2PHebseHbka4tz9xmbPi2VLm2fMK/Sv/BteXKY3gow0MZHsrwUIaHMjyU4aEMD2V4KMNDGR7K8FCGhzI8lOGhDA9leCjDQxkeyvBQhocyPJThoQwPZXgow0MZHsrwUIaHMjyU4aEMD2V4KMNDGb5d57/cZUt03uWsODR8O9Lt1dfvbTMeZvh2JNurz7vtPmfl3fLhFfVqe/X5j5yVd4uHV4bh9upLv844zPDNeLW9OnN9teGbkW6vvv5NkLXV1vDtSLZXP7/Zxxm+Le1ur1aWdrdXqw6GhzI8lOGhDA9leCjDQxkeyvBQhocyPJThoQwPZXgow0MZHsrwUIaHMjyU4aEMD2V4KMNDGR7K8FCGhzI8lOGhDA9leCjDQxkeyvBQhocyPJThW3XcPG+/CjJ8o04fHy6Hu/huS8O3I9le3e25zFmBZfh2JNurO7W84jWvV9ur+x2nYROG1+yS7dX7jNe74RuSbq/O+2ASwzck2V593uV8LsnF8C0Zbq8+fbi+6b/N2F9t+LbUuL1aC6hxe7VaYngow0MZHsrwUIaHMjyU4aEMD2V4KMNDGR7K8FCGhzI8lOGhDA9leCjDQxkeyvBQhocyPJThoQwPZXgow0MZHsrwUIaHMjyU4aEMD2V4KMNDGR7K8FCGhzI8lOGhDA9leCjDQxkeyvBQhocyPJThoQwPZXgow0MZHsrwUIaHMjyU4aEMD2V4KMNDGR7K8FCGhzI8lOGhDA9leCjDQxkeyvBQhocyPJThoQwPZXgow0MZHsrwUIaH+gf1jgdrQk+spgAAAABJRU5ErkJggg==" alt="plot of chunk unnamed-chunk-3"/> </p>

<p>We need to specify the standard deviation for the states; here I will just assume that all taxa have a state
standard deviation of 1=200</p>

<pre><code class="r">states &lt;- phy$tip.state
states.sd &lt;- 1/200
</code></pre>

<p>Then, build the likelihood as usual. The difference compared with other models is that we have to specify
the speciation and extinction functions (here, sigmoid.x and constant.x, respectively). There are a
number of other provided functions (see ?constant.x for a list), but any function that takes x as the first
argument may be used.</p>

<pre><code class="r">lik &lt;- make.quasse(phy, states, states.sd, sigmoid.x, constant.x)
</code></pre>

<p>This can be used in ML calculations as usual. There is a starting.point.quasse function that may
be useful in selecting sensible starting points, but some effort is still required to convert this into a full
vector as it just returns constant rate speciation, extinction, and diffusion rates.</p>

<pre><code class="r">p &lt;- starting.point.quasse(phy, states)
p
</code></pre>

<pre><code>##    lambda        mu diffusion 
##   0.12873   0.00000   0.01982
</code></pre>

<p>Lets ignore drift: the argument list we need is:</p>

<pre><code class="r">lik.nodrift &lt;- constrain(lik, drift ~ 0)
argnames(lik.nodrift)
</code></pre>

<pre><code>## [1] &quot;l.y0&quot;      &quot;l.y1&quot;      &quot;l.xmid&quot;    &quot;l.r&quot;       &quot;m.c&quot;       &quot;diffusion&quot;
</code></pre>

<p>A sensible starting point here might be</p>

<pre><code class="r">p.start &lt;- c(p[1], p[1], mean(states), 1, p[2:3])
names(p.start) &lt;- argnames(lik.nodrift)
p.start
</code></pre>

<pre><code>##      l.y0      l.y1    l.xmid       l.r       m.c diffusion 
##   0.12873   0.12873   0.39892   1.00000   0.00000   0.01982
</code></pre>

<pre><code class="r">
# set lower bound
lower &lt;- c(0, 0, min(states), -Inf, 0, 0)
</code></pre>

<p>Then run find.mle, as usual. The control argument here just tells the subplex algorithm to use an
initial step size of 0.1 (rather than 1), which reduces the number of function evaluations somewhat.</p>

<pre><code class="r">time.f &lt;- system.time(fit &lt;- find.mle(lik.nodrift, p.start, control = list(parscale = 0.1), 
    lower = lower, verbose = 0))
time.f
</code></pre>

<pre><code>##     user   system  elapsed 
##   752.82     0.06 34352.97
</code></pre>

<pre><code class="r">fit
</code></pre>

<pre><code>## $par
##      l.y0      l.y1    l.xmid       l.r       m.c diffusion 
## 2.734e-07 1.997e-01 1.359e-01 5.542e+04 2.314e-06 1.826e-02 
## 
## $lnLik
## [1] -26.27
## 
## $counts
## [1] 1152
## 
## $convergence
## [1] 0
## 
## $message
## NULL
## 
## $hessian
## NULL
## 
## $method
## [1] &quot;subplex&quot;
## 
## $par.full
##      l.y0      l.y1    l.xmid       l.r       m.c     drift diffusion 
## 2.734e-07 1.997e-01 1.359e-01 5.542e+04 2.314e-06 0.000e+00 1.826e-02 
## 
## $func.class
## [1] &quot;constrained&quot; &quot;quasse&quot;      &quot;dtlik&quot;       &quot;function&quot;   
## 
## attr(,&quot;func&quot;)
## QuaSSE likelihood function:
##   * Parameter vector takes 6 elements:
##      - l.y0, l.y1, l.xmid, l.r, m.c, diffusion
##   * Function constrained (original took 7 elements):
##      - drift ~ 0
##   * Function takes arguments (with defaults)
##      - pars: Parameter vector
##      - ...: Additional arguments to underlying function
##      - pars.only [FALSE]: Return full parameter vector?
##   * Phylogeny with 7 tips and 6 nodes
##      - Taxa: sp1, sp2, sp4, sp5, sp6, sp7, sp8
##   * Reference:
##      - FitzJohn (2010) doi:10.1093/sysbio/syq053
## R definition:
## function (pars, ..., pars.only = FALSE)  
## attr(,&quot;class&quot;)
## [1] &quot;fit.mle.quasse&quot; &quot;fit.mle&quot;
</code></pre>

<p><em>Time of the find.mle function</em></p>

<p>Function took 572.5495 minutes to run. Given that the desired use case involves phylogenies of many hundreds of taxa, this is far too long. </p>

<h2>Extracting the likelihood function from Quasse</h2>

<p>Let&#39;s look at the function call make.quasse</p>

<pre><code class="r">lik.nodrift
</code></pre>

<pre><code>## QuaSSE likelihood function:
##   * Parameter vector takes 6 elements:
##      - l.y0, l.y1, l.xmid, l.r, m.c, diffusion
##   * Function constrained (original took 7 elements):
##      - drift ~ 0
##   * Function takes arguments (with defaults)
##      - pars: Parameter vector
##      - ...: Additional arguments to underlying function
##      - pars.only [FALSE]: Return full parameter vector?
##   * Phylogeny with 7 tips and 6 nodes
##      - Taxa: sp1, sp2, sp4, sp5, sp6, sp7, sp8
##   * Reference:
##      - FitzJohn (2010) doi:10.1093/sysbio/syq053
## R definition:
## function (pars, ..., pars.only = FALSE)
</code></pre>

<p>The likelihood function is in there, we need to prize it out!</p>

<p>What does the structure of the function look like?</p>

<pre><code class="r">str(lik.nodrift)
</code></pre>

<pre><code>## function (pars, ..., pars.only = FALSE)  
##  - attr(*, &quot;class&quot;)= chr [1:4] &quot;constrained&quot; &quot;quasse&quot; &quot;dtlik&quot; &quot;function&quot;
##  - attr(*, &quot;argnames&quot;)= chr [1:6] &quot;l.y0&quot; &quot;l.y1&quot; &quot;l.xmid&quot; &quot;l.r&quot; ...
##  - attr(*, &quot;formulae&quot;)=List of 1
##   ..$ :Class &#39;formula&#39; length 3 drift ~ 0
##   .. .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; 
##  - attr(*, &quot;func&quot;)=function (pars, condition.surv = TRUE, root = ROOT.OBS, root.f = NULL, 
##     intermediates = FALSE)  
##   ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;quasse&quot; &quot;dtlik&quot; &quot;function&quot;
</code></pre>

<pre><code class="r">lik.nodrift
</code></pre>

<pre><code>## QuaSSE likelihood function:
##   * Parameter vector takes 6 elements:
##      - l.y0, l.y1, l.xmid, l.r, m.c, diffusion
##   * Function constrained (original took 7 elements):
##      - drift ~ 0
##   * Function takes arguments (with defaults)
##      - pars: Parameter vector
##      - ...: Additional arguments to underlying function
##      - pars.only [FALSE]: Return full parameter vector?
##   * Phylogeny with 7 tips and 6 nodes
##      - Taxa: sp1, sp2, sp4, sp5, sp6, sp7, sp8
##   * Reference:
##      - FitzJohn (2010) doi:10.1093/sysbio/syq053
## R definition:
## function (pars, ..., pars.only = FALSE)
</code></pre>

<pre><code class="r">
# provide pars
pars &lt;- c(0.1, 0.2, 0, 2.5, 0.03, 0.01)

lik.nodrift(pars)
</code></pre>

<pre><code>## [1] -28.93
</code></pre>

<pre><code class="r">
# what are these paramters!! in what order??
</code></pre>

<p>calling lik.nodrift</p>

<ul>
<li>l.y0, l.y1, l.xmid, l.r, m.c, diffusion

<ul>
<li>Function constrained (original took 7 elements):

<ul>
<li>drift ~ 0</li>
</ul></li>
</ul></li>
</ul>

<p>This would appear to be the the -log liklihood for this tree. We need to find the actually function inside!</p>

<p>Let&#39;s try calling a debug (not seen within R markdown)</p>

<p>I see the call</p>

<p>lik(pars)
debugging in: lik(pars)
debug: {
    pars2 &lt;- f.pars(pars)
    ans &lt;- all.branches(pars2, intermediates)
    rootfunc(ans, pars2, condition.surv, root, root.f, intermediates)
}</p>

<p>I don&#39;t see any documentation on the functions rootfunc or pars.</p>

<h1>Where to go from here</h1>

<ol>
<li><p>We can email Rich and ask him to report where the function is actually being held. It has to exist.</p></li>
<li><p>We can remake the function from the going back to the original paper (antonin?)</p></li>
<li><p>We can try to code just a new function type, within the find.mle framework, and just ignore where the actual function call is (this seems kinda crazy, but possible, see below)</p></li>
</ol>

<h1>Treating Quasse as a black box</h1>

<pre><code class="r">
# reformat lower bound into the correct syntax
lower &lt;- c(0, 0, 0, 0, 0, 0)

# is there an upper bound?
upper &lt;- c(1, 1, 1, 1, 1, 1)
bounds &lt;- cbind(lower, upper)

require(ppso)

result &lt;- optim_pso(objective_function = lik.nodrift, number_of_parameter = 6, 
    parameter_bounds = bounds, initial_estimates = p.start, projectfile = NULL, 
    logfile = NULL, do_plot = &quot;base&quot;, tryCall = TRUE)

result
</code></pre>

<p>$value
[1] -63.49</p>

<p>$par
[1] 1.0000 1.0000 0.3175 0.5946 0.0000 1.0000</p>

<p>$function_calls
[1] 200</p>

<p>$break_flag
[1] &ldquo;max iterations reached&rdquo;</p>

<p>This fails with the bounds! What are the upper bounds? just 1, i&#39;m confused here but thats progressed.</p>

</body>

</html>

